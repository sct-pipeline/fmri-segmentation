import numpy as np
import nibabel as nib
import os
from scipy.spatial.distance import directed_hausdorff
import argparse
import glob
import statistics
import csv
import matplotlib.pyplot as plt
"""
This script calculates the Dice coefficient and the Hausdorff Distance between the predicted segmentation masks and the ground truth masks.
Usage: python get_metrics.py --predictions_dir <PATH_TO_PREDS>    
            --ground_truth_dir <PATH_TO_GT>
             --output_file <PATH_TO_CSV> --pred_suffix <PREDICTION_SUFFIX>

NOTE: The script assumes that the predictions and the ground truth masks are stored in the same directory structure as the one generated by the preprocessing script i.e. in BIDS format.

Example dataset:

├── derivatives
│	 └── labels
│	     ├── sub-001
│	     │	 └── func
│	     │	     ├── sub-001_bold_seg-manual.json
│	     │	     ├── ssub-001_bold_seg-manual.nii.gz
│	     │	     ├── sub-001_bold_seg-sc_epi.json
│	     │	     └── sub-001_bold_seg-sc_epi.nii.gz
│	     ├       └── sub-001_bold_seg-deepseg.json
│	     │       └── sub-001_bold_seg-deepseg.nii.gz
│	     ├       └── sub-001_bold_seg-propseg.json
│	     │       └── sub-001_bold_seg-propseg.nii.gz
│
├── sub-001
│	 └── func
│	     ├── sub-5416_T2w.json
│	     └── sub-5416_T2w.nii.gz


Author: Rohan Banerjee
"""

def dice_coefficient(seg1, seg2, smooth = 1):
    intersection = np.sum(seg1[seg2==1])
    union = np.sum(seg1) + np.sum(seg2)
    if union == 0:
        return 1.0
    else:
        return 2.0 * intersection / union
    
def hausdorff_distance_calc(seg1, seg2):
    predicted_coords = np.argwhere(seg1)
    truth_coords = np.argwhere(seg2)

    hausdorff_distance = max(directed_hausdorff(predicted_coords, truth_coords)[0],
                             directed_hausdorff(truth_coords, predicted_coords)[0])

    return hausdorff_distance

# def generate_plot():
    


# Load the segmentation masks

all_dice = []

def main(predictions_dir, ground_truth_dir, pred_suffix, output_file):
    test_files = [file_name for file_name in os.listdir(predictions_dir) if file_name.endswith('.nii.gz')]
    test_files = [file_name for file_name in test_files if file_name != '.DS_Store']
    subjects = [file_name.split('_')[0] for file_name in test_files]
    
    all_dice = []
    all_hausdorff = []

    for i in range(len(subjects)):
        
        if args.data_type == "bids":
            mask1 = os.path.join(predictions_dir, subjects[i], "func", subjects[i] + pred_suffix + ".nii.gz")
            mask2_files = glob.glob(os.path.join(ground_truth_dir, subjects[i], "func", subjects[i] + "*_seg-manual.nii.gz"))
        else:
            mask1_files = glob.glob(os.path.join(predictions_dir, subjects[i] + "*" + pred_suffix + ".nii.gz"))
            if mask1_files:
                mask1 = mask1_files[0]
            mask2_files = glob.glob(os.path.join(ground_truth_dir, subjects[i], "func", subjects[i] + "*_seg-manual.nii.gz"))

        # mask1 = os.path.join(predictions_dir, subjects[i],  "func", subjects[i] + pred_suffix + ".nii.gz")
        # mask2_files = glob.glob(os.path.join(ground_truth_dir, subjects[i], "func", subjects[i] + "*_seg-manual.nii.gz"))
        if mask2_files:
            mask2 = nib.load(mask2_files[0])
        else:
            print(f"No file found for subject {subjects[i]}")
            continue
        
        if os.path.exists(mask1) and os.path.getsize(mask1) > 0:
            mask1 = nib.load(mask1)
            data1 = mask1.get_fdata()
            data2 = mask2.get_fdata()

            dice1_2 = dice_coefficient(data2, data1)
            hausdorff1_2 = hausdorff_distance_calc(data1, data2)
            # print("Subject: ", subjects[i])
            # print("Dice: ", dice1_2)
            # print("Hausdorff: ", hausdorff1_2)
            all_dice.append(dice1_2*100)
            all_hausdorff.append(hausdorff1_2)
        else:
            # handle the case where mask1 is not present
            dice1_2 = 0
            hausdorff1_2 = 100

    mean_dice = statistics.mean(all_dice)
    std_dev_dice = statistics.stdev(all_dice)
    mean_hausdorff = statistics.mean(all_hausdorff)
    std_dev_hausdorff = statistics.stdev(all_hausdorff)

    print("Dice: ", statistics.mean(all_dice), statistics.stdev(all_dice))
    print("Hausdorff: ",statistics.mean(all_hausdorff), statistics.stdev(all_hausdorff))

    with open(output_file, 'a', newline='') as csvfile:
        writer = csv.writer(csvfile, delimiter=',')
        if csvfile.tell() == 0:
        #     writer.writerow(["Ground Truth Filename", "Prediction Filename", "Dice Score", "Hausdorff Distance"])
        # writer.writerow([subjects[i] + "_seg-manual.nii.gz", subjects[i] + pred_suffix + ".nii.gz", dice1_2, hausdorff1_2])
            writer.writerow(["Model", "Dice Score", "Hausdorff Distance"])
        writer.writerow([pred_suffix, "{:.2f}".format(mean_dice) + "+-" + "{:.2f}".format(std_dev_dice), "{:.2f}".format(mean_hausdorff) + "+-" + "{:.2f}".format(std_dev_hausdorff)])

    # print(all_dice)
    # print(all_hausdorff)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Calculate Dice Coefficients.')
    parser.add_argument('--predictions_dir', type=str, required=True, help='Directory where the predictions are stored')
    parser.add_argument('--ground_truth_dir', type=str, required=True, help='Directory where the ground truth masks are stored')
    parser.add_argument('--output_file', type=str, required=True, help='Output file to save the Dice coefficients')
    parser.add_argument('--pred_suffix', type=str, required=True, help='Suffix of the prediction files')
    parser.add_argument('--data_type', type=str, required=True, help='Suffix of the prediction files')
    args = parser.parse_args()

    main(args.predictions_dir, args.ground_truth_dir, args.pred_suffix, args.output_file)
